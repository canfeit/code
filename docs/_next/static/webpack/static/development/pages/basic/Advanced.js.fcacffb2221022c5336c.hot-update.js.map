{"version":3,"file":"static/webpack/static\\development\\pages\\basic\\Advanced.js.fcacffb2221022c5336c.hot-update.js","sources":["webpack:///./pages/basic/Advanced.js"],"sourcesContent":["import Layout from '../../layout';\r\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\r\n\r\nexport default () => {\r\n    return <Layout cat='basic' id='Advanced'>\r\n        <SyntaxHighlighter language=\"typescript\">\r\n            {`//交叉类型，将多个类型合并为一个类型。 它包含了所有类型的特性，同时拥有了所有类型的成员。\r\ninterface a {a:string;}\r\ninterface b {b:string;}\r\nconst ab:a&b={a:'1',b:'2'}//使用交叉类型a&b声明ab\r\n//联合类型表示一个值可以是几种类型之一。 用竖线（|）分隔每个类型\r\nfunction getSmallPet(): Fish | Bird {}//返回值可以是Fish或Bird类型。\r\nlet pet = getSmallPet();//默认只能访问pet联合类型（Fish|Bird）里共有的成员\r\n//类型守卫\r\nfunction isFish(pet: Fish | Bird): pet is Fish {//pet is Fish就是类型谓词。 谓词为param is Type这种形式，param必须为当前函数的参数\r\n    return (pet as Fish).swim !== undefined;\r\n}\r\nif (isFish(pet)) pet.swim();//TypeScript知道在if分支里pet是Fish类型，在else分支里是Bird类型\r\nelse pet.fly();\r\n//typeof类型守卫，typeof v === \"typename\"和typeof v !== \"typename\"能被自动识别为类型守卫，\"typename\"必须是\"number\"，\"string\"，\"boolean\"或\"symbol\"。 \r\nif (typeof padding === \"number\") {}\r\n//instanceof类型守卫\r\nif (padder instanceof SpaceRepeatingPadder) {}\r\n//非空类型断言,!后缀\r\nfunction fixed(name: string | null): string { return name!.charAt(0) }//声明此处name不是null或undefined（此处示例不当）\r\n//类型别名，给类型起个新名字，不会新建类型而是创建了一个新名字来引用那个类型\r\ntype Tree<T> = {//使用类型别名在属性里引用自己\r\n    value: T;\r\n    left: Tree<T>;\r\n    right: Tree<T>;\r\n}\r\n`}\r\n        </SyntaxHighlighter>\r\n        <>rs</>\r\n        <>kt</>\r\n        <>py</>\r\n    </Layout>\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgCA;;;;A","sourceRoot":""}